synchronized:
  Java的关键字，在jvm层面上.
  1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁
  假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待
  锁状态无法判断
  可重入 不可中断 非公平
 Lock：
  是一个类
  在finally中必须释放锁，不然容易造成线程死锁
  分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待
  锁状态可以判断
  可重入 可中断 可公平
  
synchronized底层靠字节码实现：monitorenter、monitorexit.
  当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。
synchronized优化：线程自旋和适应性自旋 ，锁消除 ，锁粗化 ，轻量级锁，偏向锁。


对象锁：
锁住同一个对象。方法加synchronized。

全局锁：
使用synchronized锁住这个类对应的Class对象。方法加static或者synchronized修饰class

对象锁只能锁住当前对象，如果有多个对象对同一个全局变量进行操作，这是就需要全局锁。
